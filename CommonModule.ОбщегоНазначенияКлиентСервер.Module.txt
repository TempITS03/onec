////////////////////////////////////////////////////////////////////////////////
// Клиентские и серверные процедуры общего назначения

// Формирует и выводит сообщение об ошибке при заполнении реквизита Поле
// объекта Объект. Для использования в обработчиках проверки заполнения.
//
// Параметры
//  ТекстСообщенияПользователю  - Строка - текст сообщения.
//  Объект  - Ссылка или данные формы - объект, редактируемый в форме.
//  Поле  - Строка - идентификатор элемента формы.
//  Отказ  - Булево - возвращается значение Истина.
//
// Пример использования:
//   ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//	    НСтр("ru = 'Необходимо указать причину, по которой задача не выполнена.'"),
//	    Объект,
//	    "ОписаниеРезультата",
//	    Отказ);
//
Процедура СообщитьПользователю(Знач ТекстСообщенияПользователю,
                               Знач Объект = Неопределено,
                               Знач Поле = "",
                               Отказ = Ложь) Экспорт

	Сообщение = Новый СообщениеПользователю();
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле = Поле;
	Сообщение.УстановитьДанные(Объект);
	Сообщение.Сообщить();
	Отказ = Истина;

КонецПроцедуры

// Удаляет отбор у отбора системы компоновки данных
//
// Пример использования:
//   УдалитьОтборУСписка(Список.Отбор, Новый ПолеКомпоновкиДанных("Куратор"));
//
Процедура УдалитьОтборУСписка(ОтборСКД, ЛевоеЗначение) Экспорт
	
	ЭлементыОтбора = ОтборСКД.Элементы;
	
	МассивОтборов = Новый Массив;
	
	Для Каждого ЭлементОтбора Из ЭлементыОтбора Цикл
		Если ЭлементОтбора.ЛевоеЗначение = ЛевоеЗначение Тогда
			МассивОтборов.Добавить(ЭлементОтбора);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ЭлементОтбора Из МассивОтборов Цикл
		ЭлементыОтбора.Удалить(ЭлементОтбора);
	КонецЦикла;
	
КонецПроцедуры

// Устанавливает отбор у отбора системы компоновки данных.
//
//  Пример использования:
//   ОбщегоНазначенияКлиентСервер.УстановитьОтборУСпискаНаРавенство(
//                   Список.Отбор,
//                   Новый ПолеКомпоновкиДанных("ИмяСвойства"),
//                   ЗначениеОтбора);
//
Процедура УстановитьОтборУСпискаНаРавенство(ОтборСКД,
                                            знач ЛевоеЗначение,
                                            знач ПравоеЗначение) Экспорт
	
	ЭлементыОтбора = ОтборСКД.Элементы;
	ЭлементОтбораДанных = Неопределено;
	
	Для Каждого ЭлементОтбора Из ЭлементыОтбора Цикл
		Если ЭлементОтбора.ЛевоеЗначение = ЛевоеЗначение Тогда
			Если ЭлементОтбораДанных = Неопределено Тогда
				ЭлементОтбораДанных = ЭлементОтбора;
			Иначе
				ЭлементОтбора.Использование = Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если ЭлементОтбораДанных = Неопределено Тогда
		ЭлементОтбораДанных = ЭлементыОтбора.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ЭлементОтбораДанных.ЛевоеЗначение = ЛевоеЗначение;
	КонецЕсли;
	
	ЭлементОтбораДанных.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ЭлементОтбораДанных.ПравоеЗначение = ПравоеЗначение;
	ЭлементОтбораДанных.Использование = Истина;
	
КонецПроцедуры

//Удаляет из доступных полей отбора указанной настройки
//
Процедура УдалитьИзДоступныхПолейОтбора(ДоступныеПоляОтбора,
										знач Заголовок,
										знач ТипДанных) Экспорт
										
	ЭлементыОтбора = ДоступныеПоляОтбора.Элементы;
	Для Каждого ДоступноеПоле Из ЭлементыОтбора Цикл
		Если (ДоступноеПоле.Заголовок = Заголовок) 
			и (ДоступноеПоле.Тип = ТипДанных) Тогда
				ЭлементыОтбора.Удалить(ДоступноеПоле);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры	

////////////////////////////////////////////////////////////////////////////////
// Блок функций для работы с почтовыми адресами
//

// Функция проверяет что введенная строка с e-mail адресами введена правильно
//
// Формат строки:
// Z = ИмяПользователя|[Имя Пользователя] [<]пользователь@почтовыйсервер[>], Строка = Z[<разделитель*>Z]..
// 
//   прим.: разделитель* - имеется в виду любой разделитель адресов
//
// Параметры:
// СтрокаАдресов - строка - правильная строка с почтовыми адресами
//
// Возвращаемое значение:
// Структура
// ключ Статус - булево - успех или неуспех преобразования
// в случае успеха содержит ключ Значение:
//           Массив структур, где
//                  Адрес- e-mail получателя
//                  Представление   - имя получателя
// в случае неуспеха содержит ключ СообщениеОбОшибке - строка
//
//  ВАЖНО: Функция возвращает массив структур, в которых одно поле (любое)
//         может быть незаполнено. Может использоваться различными
//         подсистемами для собственного сопоставления имени пользователя
//         некому e-mail адресу. Поэтому, необходимо перед непосредственной
//         отправкой проверить, что поле почтового адреса заполнено.
//
Функция РазобратьСтрокуСПочтовымиАдресами(знач СтрокаАдресов) Экспорт
	
	Результат = Новый Массив;
	
	НедопустимыеСимволы = "!#$%^&*()+`~|\/=";
	ДопустимыеСимволыEMAIL = "abcdefghijklmnopqrstuvwxyz.-_0123456789";
	СимволыРазделители = ";,";
	
	Индекс = 1;               // номер обрабатываемого символа
	Накопитель = "";          // накопитель символов, после анализа перемещается либо в полное имя
	                          // либо в почтовый адрес
	ПолноеИмяАдресата = "";   // переменная, накапливающая имя адресата
	ПочтовыйАдрес = "";       // переменная, накапливающая e-mail адрес
	СтадияРазбора = 1; // 1 - формирование полного имени: ожидаются любые допустимые символы имени адресата
	                   // 2 - формирование почтового адреса: ожидаются любые допустимые символы email адреса
	                   // 3 - завершение формирования очередного почтового адреса - ожидаются символы разделители либо пробелы
	
	Пока Индекс <= СтрДлина(СтрокаАдресов) Цикл
		
		Символ = Сред(СтрокаАдресов, Индекс, 1);
		
		Если      Символ = " " Тогда
			Индекс = ? ((ПропуститьПробелы(СтрокаАдресов, Индекс, " ") - 1) > Индекс,
			             ПропуститьПробелы(СтрокаАдресов, Индекс, " ") - 1,
			             Индекс);
			Если      СтадияРазбора = 1 Тогда
				ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель + " ";
			ИначеЕсли СтадияРазбора = 2 Тогда
				ПочтовыйАдрес = Накопитель;
				СтадияРазбора = 3;
			КонецЕсли;
			Накопитель = "";
		ИначеЕсли Символ = "@" Тогда
			Если      СтадияРазбора = 1 Тогда
				СтадияРазбора = 2;
				Накопитель = Накопитель + Символ;
			ИначеЕсли СтадияРазбора = 2 Тогда
				ВызватьИсключение НСтр("ru = 'Неверный формат почтового адреса.'");
			ИначеЕсли СтадияРазбора = 3 Тогда
				ВызватьИсключение НСтр("ru = 'Неверный формат почтового адреса.'");
			КонецЕсли;
		ИначеЕсли Найти(СимволыРазделители, Символ) > 0 Тогда
			
			Если      СтадияРазбора = 1 Тогда
				ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель;
			ИначеЕсли СтадияРазбора = 2 Тогда
				ПочтовыйАдрес = Накопитель;
			КонецЕсли;
			
			СтадияРазбора = 1;
			
			Если Не (ПустаяСтрока(ПолноеИмяАдресата) И ПустаяСтрока(ПочтовыйАдрес)) Тогда
				Результат.Добавить(ПроверитьИПодготовитьПочтовыйАдрес(ПолноеИмяАдресата, ПочтовыйАдрес));
			КонецЕсли;
			
			ПочтовыйАдрес = "";
			ПолноеИмяАдресата = "";
			Накопитель = "";
		Иначе
			Если Найти(НедопустимыеСимволы, Символ) > 0 Тогда
				ВызватьИсключение НСтр("ru = 'Недопустимые символы в почтовом адресе.'");
			КонецЕсли;
			
			Накопитель = Накопитель + Символ;
		КонецЕсли;
		
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Если      СтадияРазбора = 1 Тогда
		ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель;
	ИначеЕсли СтадияРазбора = 2 Тогда
		ПочтовыйАдрес = Накопитель;
	КонецЕсли;

	Если Не (ПустаяСтрока(ПолноеИмяАдресата) И ПустаяСтрока(ПочтовыйАдрес)) Тогда
		Результат.Добавить(ПроверитьИПодготовитьПочтовыйАдрес(ПолноеИмяАдресата, ПочтовыйАдрес));
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Проверяет, что почтовый адрес не содержит символов обрамления
// если символы обрамления вставлены правильно убирает их
// Параметры:
//  ПолноеИмяАдресата - строка - имя получателя
//  ПочтовыйАдрес     - строка - email адрес
// Возвращаемое значение:
//  Структура:
//   Ключ статус - булево - успех или неуспех операции
//   СообщениеОбОшибке - в случае неуспеха операции содержит сообщение об ошибке
//   Значение - структура - в случае успеха операции содержит записанную структуру почтового
//                          адреса: ключи - Адрес, Представление (строки)
//
Функция ПроверитьИПодготовитьПочтовыйАдрес(знач ПолноеИмяАдресата, знач ПочтовыйАдрес)
	
	СимволыОбрамления = "<>[]";
	
	ПочтовыйАдрес     = СокрЛП(ПочтовыйАдрес);
	ПолноеИмяАдресата = СокрЛП(ПолноеИмяАдресата);
	
	Если Лев(ПолноеИмяАдресата, 1) = "<" Тогда
		Если Прав(ПолноеИмяАдресата, 1) = ">" Тогда
			ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		Иначе
			ВызватьИсключение НСтр("ru = 'Недопустимый символ в имени адресата.'");
		КонецЕсли;
	ИначеЕсли Лев(ПолноеИмяАдресата, 1) = "[" Тогда
		Если Прав(ПолноеИмяАдресата, 1) = "]" Тогда
			ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		Иначе
			ВызватьИсключение НСтр("ru = 'Недопустимый символ в имени адресата.'");
		КонецЕсли;
	КонецЕсли;
	
	Если Лев(ПочтовыйАдрес, 1) = "<" Тогда
		Если Прав(ПочтовыйАдрес, 1) = ">" Тогда
			ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		Иначе
			ВызватьИсключение НСтр("ru = 'Недопустимый символ в почтовом адресе.'");
		КонецЕсли;
	ИначеЕсли Лев(ПочтовыйАдрес, 1) = "[" Тогда
		Если Прав(ПочтовыйАдрес, 1) = "]" Тогда
			ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		Иначе
			ВызватьИсключение НСтр("ru = 'Недопустимый символ в почтовом адресе.'");
		КонецЕсли;
	КонецЕсли;
	
	Для Индекс = 1 По СтрДлина(СимволыОбрамления) Цикл
		Если Найти(ПолноеИмяАдресата, Сред(СимволыОбрамления, Индекс, 1)) <> 0
		 Или Найти(ПочтовыйАдрес,     Сред(СимволыОбрамления, Индекс, 1)) <> 0 Тогда
			ВызватьИсключение НСтр("ru = 'Недопустимый символ в почтовом адресе.'");
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("Адрес, Представление", ПочтовыйАдрес,ПолноеИмяАдресата);
	
КонецФункции

// Формирует структуру с ключами Статус (Истина) и Значение
//
Функция ЗаполнитьРезультат(знач Значение) Экспорт
	
	Возврат Новый Структура("Статус, Значение", Истина, Значение);
	
КонецФункции

// Сдвигает маркер позиции пока встречается символ Символ
// возвращает номер позиции в строке, на которое установился маркер
//
Функция ПропуститьПробелы(знач Строка,
                          знач ТекущийИндекс,
                          знач ПропускаемыйСимвол)
	
	Результат = ТекущийИндекс;
	
	// убираем лишние пробелы если они есть
	Пока ТекущийИндекс < СтрДлина(Строка) Цикл
		Если Сред(Строка, ТекущийИндекс, 1) <> ПропускаемыйСимвол Тогда
			Возврат ТекущийИндекс;
		КонецЕсли;
		ТекущийИндекс = ТекущийИндекс + 1;
	КонецЦикла;
	
	Возврат ТекущийИндекс;
	
КонецФункции

#Если Не ВебКлиент Тогда
// Генерирует имя временного каталога возвращает путь к нему
//
Функция ПолучитьИмяКаталога(знач Идентификатор) Экспорт
	
	Индекс = 0;
	
	Пока Истина Цикл
		
		ПутьККаталогу = КаталогВременныхФайлов () + Идентификатор + строка(Индекс) + "\";
		КаталогНаДиске = Новый Файл(ПутьККаталогу);
		Если НЕ КаталогНаДиске.Существует() Тогда
			СоздатьКаталог(ПутьККаталогу);
			Возврат ПутьККаталогу;
		КонецЕсли;
		Индекс = Индекс + 1;
		
	КонецЦикла;
	
КонецФункции
#КонецЕсли

// Возвращает дату из строки в формате ЧЧ.ММ.ГГГГ
//
Функция ПолучитьДатуИзСтроки(Строка) Экспорт
	
	Возврат Дата(Сред(Строка, 7, 4)+Сред(Строка, 4, 2)+Лев(Строка, 2));
	
КонецФункции

// Получает представление сообщения ошибке на основании Информации об ошибке
// Может вызываться в операторных скобках Попытка ... Исключение ... КонецПопытки;
// для получения сообщения об ошибке.
//
Функция ПолучитьПредставлениеОписанияОшибки(ИнформацияОбОшибке) Экспорт
	
	Возврат ? (ИнформацияОбОшибке.Причина = Неопределено, ИнформацияОбОшибке.Описание, ИнформацияОбОшибке.Причина.Описание);
	
КонецФункции

// Составляет полное имя файла из имени каталога и имени файла.
//
// Параметры
//  ИмяКаталога  – Строка, содержащая путь к каталогу файла на диске.
//  ИмяФайла     – Строка, содержащая имя файла, без имени каталога.
//
// Возвращаемое значение:
//   Строка – полное имя файла с учетом каталога.
//
Функция ПолучитьИмяФайла(Знач ИмяКаталога, Знач ИмяФайла) Экспорт

	Если Не ПустаяСтрока(ИмяФайла) Тогда
		
		Слэш = "";
		Если (Прав(ИмяКаталога, 1) <> "\") И (Прав(ИмяКаталога, 1) <> "/") Тогда
			Слэш = ?(Найти(ИмяКаталога, "\") = 0, "/", "\");
		КонецЕсли;
		
		Возврат ИмяКаталога + Слэш + ИмяФайла;
		
	Иначе
		
		Возврат ИмяКаталога;
		
	КонецЕсли;

КонецФункции
